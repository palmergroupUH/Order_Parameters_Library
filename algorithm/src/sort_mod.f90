!------------------------------------------- Program Descriptions ----------------------------------------

! This program contains following sorting algorithm:  
	! 1. Bubble sort
	! 2. Selection sort
	! 3. Quick sort



! Note: 
! 1. all sorting algorithm can deal with array of data type ( integer, float,
! double precision)  
! 2. A callable c interface is generated by Python or C/C++ 


module sorting 
	use system
	implicit none 
	! all variables and subroutines/functions are private  
	private 

	! Export these subroutines/functions ( other subroutines/functions are still private) : 	
	public :: 	bubble_sort,selection_sort,quick_sort

	! Global varialbes: 

! Function/Subroutine Overloading
interface find_minimum_loc 
	
	module procedure :: find_minimum_loc_int,find_minimum_loc_sp,find_minimum_loc_dp 

end interface 

interface exchange_ij 
	
	module procedure :: exchange_i_j_int,exchange_i_j_dp, exchange_i_j_sp

end interface 

interface partition 

	module procedure :: partition_int,partition_sp,partition_dp 

end interface 

interface bubble_sort 

	module procedure :: bubble_sort_int,bubble_sort_sp,bubble_sort_dp 

end interface 

interface selection_sort 

	module procedure :: selection_sort_int,selection_sort_sp, selection_sort_dp 

end interface 

interface quick_sort 

	module procedure :: quick_sort_int,quick_sort_sp,quick_sort_dp 

end interface 

contains

    pure subroutine exchange_i_j_int(array,i,j,array_index) 
            implicit none 
            integer,intent(in) :: i,j 
            integer,intent(inout),dimension(:) :: array 
            integer,intent(inout),dimension(:), allocatable :: array_index 
            integer :: temp,temp_index 

            temp = array(i) 

            array(i) = array(j) 	

            array(j) = temp 

            temp_index = array_index(i)  

            array_index(i) = array_index(j)  

            array_index(j) = temp_index 	

            end subroutine   

    pure subroutine exchange_i_j_dp(array,i,j,array_index) 
            implicit none 
            integer,intent(in) :: i,j 
            real(dp),intent(inout),dimension(:) :: array 
            integer,intent(inout),dimension(:),allocatable :: array_index 
            real(dp) :: temp 
            integer :: temp_index 

            temp = array(i) 

            array(i) = array(j) 	

            array(j) = temp 

            temp_index = array_index(i)  

            array_index(i) = array_index(j)  

            array_index(j) = temp_index 	

            end subroutine   

    pure subroutine exchange_i_j_sp(array,i,j,array_index) 
            implicit none 
            integer,intent(in) :: i,j 
            real(sp),intent(inout),dimension(:) :: array 
            integer,intent(inout),dimension(:), allocatable:: array_index 
            real(sp) :: temp 
            integer :: temp_index 

            temp = array(i) 

            array(i) = array(j) 	

            array(j) = temp 

            temp_index = array_index(i)  

            array_index(i) = array_index(j)  

            array_index(j) = temp_index 	

            end subroutine 

    !---------------------------------------------------------------------------------------
    !                                    Bubble Sort                                        
    !---------------------------------------------------------------------------------------
    pure subroutine bubble_sort_int(N,array,array_index) 
            implicit none 
            ! Passed
            integer(c_int),intent(in) :: N 

            ! Local:
            integer :: i,j  
        
            ! Return 
            integer(c_int),intent(inout),dimension(1:N) :: array
            integer(c_int),intent(out),dimension(:), allocatable :: array_index

            allocate(array_index(1:N)) 

            array_index = [ ( i,i=1,N) ]	
        
            do i = 1,N -1 

                do j = 1,N - i  
        
                    if ( array(j)  > array(j+1) ) then 
                        
                        call exchange_ij(array,j,j+1,array_index ) 	

                    end if 
            
                end do 

            end do 

            end subroutine 	

    pure subroutine bubble_sort_sp(N,array,array_index) 
            implicit none 
            ! Passed
            integer,intent(in) :: N 

            ! Local 
            integer :: i,j  

            ! Return
            real(c_float),intent(inout),dimension(1:N) :: array 
            integer(c_int), intent(out), dimension(:), allocatable :: array_index

            allocate(array_index(1:N))
            
            array_index = [ ( i,i=1,N) ]	
        
            do i = 1,N -1 

                do j = 1,N - i  
        
                    if ( array(j)  > array(j+1) ) then 
                        
                        call exchange_ij(array,j,j+1,array_index ) 	

                    end if 
            
                end do 

            end do 

            end subroutine 	

    pure subroutine bubble_sort_dp(N,array,array_index) 
            implicit none 
            ! Passed 
            integer,intent(in) :: N 
            real(dp),intent(inout),dimension(1:N) :: array 
        
            ! Local 
            integer :: i,j, flag  
    
            ! Return
            integer,intent(out),dimension(:), allocatable :: array_index 

            allocate(array_index(1:N)) 
    
            array_index = [ ( i,i=1,N) ]	

            do i = 1,N -1 

                flag = 0 

                do j = 1,N - i  
        
                    if ( array(j)  > array(j+1) ) then 
                        
                        call exchange_ij(array,j,j+1,array_index ) 	
        
                        flag = 1 

                    end if 
            
                end do 

                if ( flag ==0 ) exit 

            end do 

            end subroutine 	

    !---------------------------------------------------------------------------------------
    !                                    Selection Sort                                     
    !---------------------------------------------------------------------------------------

    pure function find_minimum_loc_int(array,start,N) result( min_index ) 
        implicit none  
        integer,intent(in) :: N,start
        integer,intent(in),dimension(1:N) :: array 
        integer :: min_val,i,min_index

        min_val = array(start) 

        min_index = start 

        do i =  start,N  

            if ( array(i) < min_val ) then 

                min_index = i 

                min_val = array(i) 

            end if 	

        end do 

        end function 

    pure function find_minimum_loc_sp(array,start,N) result( min_index ) 
        implicit none  
        integer,intent(in) :: N,start
        real(sp),intent(in),dimension(1:N) :: array 
        integer :: i,min_index   
        real(sp) :: min_val

        min_val = array(start) 

        min_index = start 

        do i =  start,N 

            if ( array(i) < min_val ) then 

                min_index = i 

                min_val = array(i) 

            end if 	

        end do 

        end function 

    pure function find_minimum_loc_dp(array,start,N) result( min_index ) 
        implicit none  
        integer,intent(in) :: N,start
        real(dp),intent(in),dimension(1:N) :: array 
        integer :: i,min_index   
        real(dp) :: min_val

        min_val = array(start) 

        min_index = start 

        do i =  start,N 

            if ( array(i) < min_val ) then 

                min_index = i 

                min_val = array(i) 

            end if 	

        end do 

        end function 

    pure subroutine selection_sort_int(N,array,array_index,first)
        implicit none 
        integer,intent(in) :: N 
        integer,intent(in),optional :: first 
        integer,intent(inout),dimension(1:N) :: array 
        integer :: i,j,min_index,N_sorted  
        integer,intent(out),dimension(:),allocatable :: array_index 

        allocate(array_index(1:N)) 

        array_index = [ ( i,i=1,N) ]	

        if ( present(first)) then 

            N_sorted = first  

        else

            N_sorted = N 

        end if 

        do i = 1, N_sorted

            min_index = find_minimum_loc(array,i,N) 

            call exchange_ij(array,i,min_index,array_index) 

        end do 	
        
        end subroutine 

    pure subroutine selection_sort_sp(N,array,array_index,first)
        implicit none 
        integer,intent(in) :: N 
        integer,intent(in),optional :: first 
        real(sp),intent(inout),dimension(1:N) :: array 
        integer :: i,j,min_index,N_sorted  
        integer,intent(out),dimension(:),allocatable :: array_index 

        allocate(array_index(1:N)) 

        array_index = [ ( i,i=1,N) ]	

        if ( present(first)) then 

            N_sorted = first  

        else

            N_sorted = N 

        end if 

        do i = 1, N_sorted 

            min_index = find_minimum_loc(array,i,N) 

            call exchange_ij(array,i,min_index,array_index ) 

        end do 	

        end subroutine 

    pure subroutine selection_sort_dp(N,array,array_index,first)
        implicit none 
        integer,intent(in) :: N 
        integer,intent(in),optional :: first 
        real(dp),intent(inout),dimension(1:N) :: array 
        integer :: i,j,min_index,N_sorted  
        integer,intent(out),dimension(:),allocatable :: array_index 

        allocate(array_index(1:N)) 

        array_index = [ ( i,i=1,N) ]	

        if ( present(first)) then 	

            N_sorted = first 
        
        else

            N_sorted = N 

        end if 

        do i = 1, N_sorted 

            min_index = find_minimum_loc(array,i,N) 

            call exchange_ij(array,i,min_index,array_index ) 

        end do 	
        
        end subroutine 

    !---------------------------------------------------------------------------------------
    !                                      Quick Sort                                       
    !---------------------------------------------------------------------------------------

    pure subroutine partition_int(array,low,high,array_index,partition_at)
        implicit none 
        integer,intent(in) :: low,high 
        integer,intent(inout),dimension(:) :: array
        integer,intent(inout),dimension(:), allocatable :: array_index 
        integer :: pivot, i,j 
        integer,intent(out) :: partition_at 

        ! last element as pivot 

        pivot = array(high) 	

        i = low -1 

        do j = low, high - 1 

            if ( array(j) <= pivot ) then 
        
                i = i + 1 
        
                ! swap i,j 	

                call exchange_ij(array,i,j,array_index)		

            end if 
            
        end do 

        call exchange_ij(array,i+1,high,array_index) 

        partition_at = (i+1) 

        end subroutine   

    pure recursive subroutine quick_sort_with_index_int(N,array,start,last,array_index) 
        implicit none 
        integer,intent(in) :: N,start,last 
        integer,intent(inout),dimension(:) :: array
        integer,intent(inout),dimension(:), allocatable :: array_index  
        integer :: q 

        if ( start < last ) then

            call partition(array,start,last,array_index,q)  

            call quick_sort_with_index_int(N,array,start,q-1,array_index) 		

            call quick_sort_with_index_int(N,array,q+1,last,array_index) 

        end if 

        end subroutine 

    pure subroutine quick_sort_int(N,array,start,last,array_index)
        implicit none 
        integer,intent(in) :: N,start,last 
        integer,intent(inout),dimension(:) :: array
        integer,intent(out),dimension(:), allocatable :: array_index 
        integer :: i 

        allocate(array_index(1:N)) 

        array_index = [ ( i,i=1,N) ] 
        
        call quick_sort_with_index_int(N,array,start,last,array_index) 

        end subroutine 

    pure subroutine partition_sp(array,low,high,array_index,partition_at)
        implicit none 
        integer,intent(in) :: low,high 
        integer,intent(inout),dimension(:), allocatable:: array_index 
        real(sp),intent(inout),dimension(:) :: array 
        integer :: i,j 
        real(sp) :: pivot 
        integer,intent(out) :: partition_at 

        pivot = array(high) 	

        i = low -1 

        do j = low, high - 1 

            if ( array(j) <= pivot ) then 
        
                i = i + 1 
            
                call exchange_ij(array,i,j,array_index)		

            end if 
            
        end do 

        call exchange_ij(array,i+1,high,array_index) 

        partition_at = (i+1) 

        end subroutine   

    pure recursive subroutine quick_sort_with_index_sp(N,array,start,last,array_index) 
        implicit none 
        integer,intent(in) :: N,start,last 
        integer,intent(inout),dimension(:), allocatable:: array_index  
        real(sp),intent(inout),dimension(:) :: array 
        integer :: q 

        if ( start < last ) then

            call partition(array,start,last,array_index,q)  

            call quick_sort_with_index_sp(N,array,start,q-1,array_index) 		

            call quick_sort_with_index_sp(N,array,q+1,last,array_index) 

        end if 

        end subroutine 

    pure subroutine quick_sort_sp(N,array,start,last,array_index)
        implicit none 
        integer,intent(in) :: N,start,last 
        real(sp),intent(inout),dimension(:) :: array
        integer,intent(out),dimension(:), allocatable :: array_index 
        integer :: i 

        allocate(array_index(1:N))

        array_index = [ ( i,i=1,N) ] 
        
        call quick_sort_with_index_sp(N,array,start,last,array_index) 

        end subroutine 

    pure subroutine partition_dp(array,low,high,array_index,partition_at)
        implicit none 
        integer,intent(in) :: low,high 
        integer,intent(inout),dimension(:),allocatable:: array_index 
        real(dp),intent(inout),dimension(:) :: array 
        integer :: i,j 
        real(dp) :: pivot 
        integer,intent(out) :: partition_at 

        pivot = array(high) 	

        i = low -1 

        do j = low, high - 1 

            if ( array(j) <= pivot ) then 
        
                i = i + 1 
            
                call exchange_ij(array,i,j,array_index)		

            end if 
            
        end do 

        call exchange_ij(array,i+1,high,array_index) 

        partition_at = (i+1) 

        end subroutine   

    pure recursive subroutine quick_sort_with_index_dp(N,array,start,last,array_index) 
        implicit none 
        integer,intent(in) :: N,start,last 
        integer,intent(inout),dimension(:), allocatable:: array_index
        real(dp),intent(inout),dimension(:) :: array
        integer :: q 

        if ( start < last ) then

            call partition(array,start,last,array_index,q)  

            call quick_sort_with_index_dp(N,array,start,q-1,array_index) 		

            call quick_sort_with_index_dp(N,array,q+1,last,array_index) 

        end if 

        end subroutine 

    pure subroutine quick_sort_dp(N,array,start,last,array_index)
        implicit none 
        integer,intent(in) :: N,start,last 
        real(dp),intent(inout),dimension(:) :: array
        integer,intent(out),dimension(:), allocatable :: array_index 
        integer :: i 

        allocate(array_index(1:N)) 

        array_index = [(i,i=1,N)] 
        
        call quick_sort_with_index_dp(N,array,start,last,array_index) 

        end subroutine 

end module 
